---
tags: [ROS2]
title: 散的知识点
created: '2025-07-29T13:24:44.737Z'
modified: '2025-08-10T12:26:42.013Z'
---

# 散的知识点

[返回根目录](./ROS2目录.md)

<p id = "directory">目录</p>

可以 `-h`查看文档

## 工具：rqt
终端执行`rqt`以进入图形界面
### 节点
在`plugins`的`introspection`中查看节点关系

## ros2 工具

### echo
查看话题下的消息
```bash
ros2 <package> echo /<topic_name>
```

### service
向服务端发送请求
```bash
ros2 service call /<topic> <interface_type>  "<request_argument_in_json>"
#例如
ros2 service call /add_ints interfaces/srv/AddInts  "{'num1': 10
, 'num2': 30}"
```

### action
向动作服务端发送目标
```bash
ros2 action send_goal /get_sum interfaces/action/Progress -f "{'num': 10}"#参数形式同上
```

### interface
查看编译好的接口文件
```bash
ros2 interface show <package_name>/<path>
#不要加.msg等后缀！
```

## ros2 pkg命令行
|类型|命令|作用|
|---|---|---|
|创建|`pkg create 包名 --build-type <type> --dependencies <dependence list> --node-name <exe name>`|新建功能包|

|参数|说明|
|---|---|
|`--build-type`|功能包的构建类型，有cmake、ament_cmake、ament_python三种类型可选，默认ament_cmake|
|`--dependencies`|所依赖的功能包列表|
|`--node-name`|可执行程序的名称，会自动生成对应的源文件并生成配置文件|

|类型|命令|作用|
|---|---|---|
|查找|`pkg executables <package name>`|输出所有功能包或指定功能包下的可执行程序|
||`pkg list | grep -i <keyword>`|列出功能包,无参数则列出全部|
||`pkg prefix <package name>`|列出功能包路径|
||`pkg xml <package name>`|输出功能包的package.xml内容|

## ros2 其它命令行
|类型|命令|作用|
|---|---|---|
|执行|`ros2 run <package> <executable> <argument,if have>`|执行|

## colcon命令行
|命令|含义|
|---|---|
|`build --packages-select <package name>`|选择编译的包，可以选一个或多个，无该参数则为全部|
|``||
|``||
|``||
|``||
|``||

## rclcpp::
|函数|作用|
|---|---|
|`init(argc,argv)`|初始化,创建context对象，context对象是各节点间写入读取数据的媒介|
|`shutdown()`|释放资源，销毁context对象|
|`span(node)`|保持节点运行,<br>等待并执行节点的各种回调,<br>处理来自 DDS 层的事件和消息|
|``||
|``||
|``||

### 模板
#### 模板函数
```cpp
create_publisher<std_msgs::msg::...>(<topic_name>, 10);
/*
创建模板，被发布的消息类型
参数：话题，QOS(消息队列长度)
返回值：发布对象指针
*/
```
```cpp
create_wall_timer(1s, std::bind(&Publisher::on_timer, this));
/*
有默认模版
参数：时间间隔，回调函数
返回值：定时器对象指针
*/
```
```cpp
template<
  class MessageT, //消息类型
  class CallbackT, //回调函数，在函数参数中，因此无需再创建
  class AllocatorT = std::allocator<...>, class SubscriptionT = rclcpp::Subscription<...>, class MessageMemoryStrategyT = SubscriptionT::MessageMemoryStrategyType> 

std::shared_ptr<...> //返回类型
rclcpp::Node::create_subscription(
  const std::string &topic_name, //话题
  const rclcpp::QoS &qos, //Qos长度
  CallbackT &&callback, //回调函数
  const rclcpp::SubscriptionOptionsWithAllocator<...> &options = rclcpp::template SubscriptionOptionsWithAllocator<...>(), MessageMemoryStrategyT::SharedPtr msg_mem_strat = MessageMemoryStrategyT::create_default())

```

```cpp
//rclcpp::action下的模板函数

create_service<>()//创建服务端


typename Server<ActionT>::SharedPtr//返回指针
create_server(
  NodeT node, //节点
  const std::string & name, //话题
  typename Server<ActionT>::GoalCallback handle_goal, //回调函数 处理目标值
  typename Server<ActionT>::CancelCallback handle_cancel, //回调函数，处理请求取消
  typename Server<ActionT>::AcceptedCallback handle_accepted, //回调函数，连续反馈
  const rcl_action_server_options_t & options = rcl_action_server_get_default_options(),
  rclcpp::CallbackGroup::SharedPtr group = nullptr)


using GoalCallback = std::function<GoalResponse(
        const GoalUUID &, std::shared_ptr<const typename ActionT::Goal>)>;
  /// Signature of a callback that accepts or rejects requests to cancel a goal.
  using CancelCallback = std::function<CancelResponse(std::shared_ptr<ServerGoalHandle<ActionT>>)>;
  /// Signature of a callback that is used to notify when the goal has been accepted.
  using AcceptedCallback = std::function<void (std::shared_ptr<ServerGoalHandle<ActionT>>)>;



create_client<>()//创建客户端

template<typename ActionT, typename NodeT>
typename Client<ActionT>::SharedPtr //返回指针
create_client(
  NodeT node,  //节点
  const std::string & name, //话题名称
  rclcpp::CallbackGroup::SharedPtr group = nullptr,
  const rcl_action_client_options_t & options = rcl_action_client_get_default_options())

```

## 流程
1. 选定一个空目录，并在目录下创建src文件夹
2. 执行`colcon build`生成一些配置文件
3. 在src下，创建包`ros2 pkg create`，将生成文件夹
4. 在新文件夹下有src文件夹，编辑源代码

