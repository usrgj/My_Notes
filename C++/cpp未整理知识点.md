---
tags: [cpp]
title: cpp语法
created: '2025-03-12T05:40:45.852Z'
modified: '2025-08-01T06:39:39.039Z'
---

## **待学**

模板元

多线程

编译期反射

错误处理

元编程


### 内联函数
在 c/c++ 中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 inline 修饰符，表示为内联函数。  




# [**线程**](https://blog.csdn.net/u010349629/article/details/130569746)

## 什么是线程？

​	线程是操作系统调度的基本单位

## 线程的生命周期

​	创建、运行、线程流程控制、等待其他线程完成、销毁线程

## 线程的状态
- 新创建状态：线程被创建但还未开始运行。
- 就绪状态：线程已经准备就绪，等待CPU调度执行。
- 运行状态：线程正在运行中。
- 阻塞状态：线程因等待某个事件而暂停执行。
- 死亡状态：线程退出或被终止。

# **多线程**



学习链接

[C++多线程编程实践：从基础到实例的全面指南](https://blog.csdn.net/u010349629/article/details/130569746)

[菜鸟](https://www.runoob.com/cplusplus/cpp-libs-thread.html)

[知乎](https://zhuanlan.zhihu.com/p/613630658)

## 为什么需要多线程

​	在执行多个任务时，多进程就已经可以实现并发编程的效果了，可是却有一个明显的缺点。 

​	**缺点**：进程的创建都需要大量的资源（例如：PCB、硬盘资源等），因此**开销就变大**了；而且创建时需要大量的资源，也是需要更多的时间，因此导致**速度变慢**了。

***\*解决方法：\****为了解决进程的缺点，于是提出了可以 **共享** 两字，先创建一个进程并且分配好资源，后续创建的进程创建时只需要分配一个简单PCB，然后 **共享** 第一个进程的文件描述表、内存硬盘等资源，从而使开销减小、速度更快。而后续的进程便是轻量级进程----线程

​	多线程程序在提高计算机系统的并发性和响应性方面有着极其重要的作用。它可以更好地利用计算机的多核和多处理器资源，在提高系统吞吐量的同时缩短响应时间。常见的使用场景包括：

- 程序需要用户交互并保持响应性
- 后台任务需要异步完成
- 大量计算密集型任务需要加速

## 线程的同步和互斥

C++11 及以后的标准提供了多线程支持，核心组件包括：

- **`std::thread`**：用于创建和管理线程。
- **`std::mutex`**：用于线程之间的互斥，防止多个线程同时访问共享资源。
- **`std::lock_guard`** 和 **`std::unique_lock`**：用于管理锁的获取和释放。
- **`std::condition_variable`**：用于线程间的条件变量，协调线程间的等待和通知。
- **`std::future`** 和 **`std::promise`**：用于实现线程间的值传递和任务同步。

### 同步

​	线程同步是指多个线程按照一定规律协调工作，使得这些线程在空间、时间上按照既定规律有序地执行工作。实现方式一般有：

- 互斥量（Mutex）
- 信号量（Semaphore）
- 事件（Event）
- 条件变量（Condition Variable）

### 互斥

​	线程互斥是指在多线程环境下，所有线程都要访问共享资源，但同一时刻只能有一个线程访问。实现方式一般有：

- 互斥量（Mutex）
- 信号量（Semaphore）





# **I/O**

## [**控制小数点位数、有效数字**](https://blog.csdn.net/m0_46515080/article/details/113574746)

## 高精度计算

​	显然，对于天文数字，编程语言的数据类型都无法存储，因此最直接的方法是将它存入一个字符串。

# **Thread**

# [**Vector**](https://cppreference.cn/w/cpp/container/vector)**（STL的一个类）**

`<vector>` 是 STL 中的一个容器类，用于存储动态大小的数组。

`<vector>` 是一个序列容器，它允许用户在容器的末尾快速地添加或删除元素。与数组相比，`<vector>` 提供了更多的功能，如自动调整大小、随机访问等。

## **初始化**

```c++
#include <vector>

std::vector<int> vec1 = {1, 2, 3, 4}; // 直接列表初始化
std::vector<int> vec2 {5, 6, 7};      // 统一初始化语法
std::vector<int> vec3(5);        // 5个元素，默认值0
std::vector<int> vec4(3, 100);   // 3个元素，每个都是100
```

## **2. 追加元素**

#### (1) `push_back`（尾部添加）

```c++
std::vector<int> vec;
vec.push_back(10);   // vec = {10}
vec.push_back(20);   // vec = {10, 20}
```

#### (2) `emplace_back`（直接构造元素，效率更高 - C++11 起）

```c++
struct Point {
    int x, y;
    Point(int a, int b) : x(a), y(b) {}
};

std::vector<Point> points;
points.emplace_back(1, 2); // 直接构造 Point(1,2)，无需临时对象
```

#### (3) `insert`（指定位置插入）

```c++
vec.insert(vec.begin(), 5);     // 在开头插入5 → {5, 10, 20}
vec.insert(vec.end(), {30, 40}); // 末尾插入多个元素 → {5,10,20,30,40}
```

## **3. 覆盖/修改现有元素**

#### (1) 下标操作符 `[]`

```c++
vec = 100; // 修改第一个元素 → {100, 10, 20}
```

#### (2) `at`（带边界检查）

```c++
vec.at(1) = 200; // 修改第二个元素 → {100, 200, 20}
```

#### (3) 使用迭代器

```c++
auto it = vec.begin() + 2;
*it = 300; // 修改第三个元素 → {100, 200, 300}
```

## **4. 拷贝其他容器的内容**

#### (1) 赋值操作符 `=`

```c++
std::vector<int> vecA = {1, 2, 3};
std::vector<int> vecB;
vecB = vecA; // vecB = {1, 2, 3}
```

#### (2) `assign`（覆盖现有内容）

```c++
vecB.assign({4, 5, 6});       // 直接赋值 → {4,5,6}
vecB.assign(vecA.begin(), vecA.end()); // 拷贝vecA全部内容 → {1,2,3}
vecB.assign(5, 10);           // 5个10 → {10,10,10,10,10}
```

#### (3) 范围构造函数

```c++
int arr[] = {7, 8, 9};
std::vector<int> vecC(arr, arr + 3); // 拷贝数组 → {7,8,9}
```

## **5. 清空并重置**

```c++
vec.clear();          // 清空所有元素（size=0，capacity不变）
vec.shrink_to_fit();  // 释放未使用内存（C++11 起）
vec = {10, 20, 30};   // 重新赋值 → {10,20,30}
```

## **6. 高级用法（C++11 起）**

#### (1) 移动语义（高效转移资源）

```c++
std::vector<int> vecD = std::move(vecC); 
// vecC 变为空，vecD 获得原vecC的数据
```

#### (2) 交换内容

```c++
std::vector<int> vecE {100, 200};
vecD.swap(vecE); // vecD 和 vecE 内容交换
```

## **7.作为函数参数**

### **1. 按值传递（Pass by Value）**

```c++
#include <vector>

// 函数会拷贝整个 vector
void processVector(std::vector<int> vec) {
    // 可以修改 vec 的内容（不影响原始 vector）
}

int main() {
    std::vector<int> data = {1, 2, 3};
    processVector(data); // 拷贝 data 到函数参数
}
```

#### **适用场景**：

- 需要独立修改函数内的副本，不影响原始数据。
- **缺点**：拷贝大容量的 `vector` 会降低性能（时间复杂度 O(n)）。

### **2. 按引用传递（Pass by Reference）**

```c++
// 函数直接操作原始 vector（无拷贝）
void modifyVector(std::vector<int>& vec) {
    vec.push_back(4); // 修改原始 vector
}

int main() {
    std::vector<int> data = {1, 2, 3};
    modifyVector(data); // data 变为 {1, 2, 3, 4}
}
```

#### **适用场景**：

- 需要修改原始 `vector`。
- **优点**：避免拷贝开销。
- **注意**：确保传入的 `vector` 生命周期足够长（避免悬垂引用）。

### **3. 按常量引用传递（Pass by Const Reference）**

```c++
// 函数只读取 vector，不修改它
void readVector(const std::vector<int>& vec) {
    for (int num : vec) {
        std::cout << num << " "; // 只读操作
    }
}

int main() {
    std::vector<int> data = {1, 2, 3};
    readVector(data); // 无拷贝，安全读取
}
```

#### **适用场景**：

- 只读取 `vector`，无需修改。
- **优点**：无拷贝开销，且防止意外修改。

### **4. 传递指针（Pass by Pointer）**

```c++
// 通过指针操作原始 vector
void updateVector(std::vector<int>* vec) {
    if (vec) { // 检查空指针
        vec->push_back(4);
    }
}

int main() {
    std::vector<int> data = {1, 2, 3};
    updateVector(&data); // data 变为 {1, 2, 3, 4}
}
```

#### **适用场景**：

- 需要显式处理可能的空指针（如动态分配的场景）。
- **缺点**：语法较繁琐，需手动检查指针有效性。

### **5. 传递迭代器范围（Pass Iterator Range）**

```c++
// 接受任意容器的迭代器范围
template <typename Iterator>
void processRange(Iterator begin, Iterator end) {
    for (auto it = begin; it != end; ++it) {
        std::cout << *it << " ";
    }
}

int main() {
    std::vector<int> data = {1, 2, 3};
    processRange(data.begin(), data.end()); // 输出 1 2 3
}
```

#### **适用场景**：

- 需要泛型处理不同容器或子范围。
- **优点**：灵活，不依赖特定容器类型。

### **6. 使用移动语义（C++11 起）**

```c++
// 通过移动语义高效转移资源
void takeOwnership(std::vector<int>&& vec) {
    // vec 是右值引用，可以安全“窃取”其内存
}

int main() {
    takeOwnership(std::vector<int>{1, 2, 3}); // 传递临时对象
    std::vector<int> data = {4, 5, 6};
    takeOwnership(std::move(data)); // 显式移动 data（data 变为空）
}
```

#### **适用场景**：

- 需要高效转移 `vector` 所有权（避免拷贝）。
- **注意**：移动后原 `vector` 不再可用。

### **总结**

| **传递方式**         | **语法**                                  | **性能** | **是否修改原数据** | **适用场景**             |
| -------------------- | ----------------------------------------- | -------- | ------------------ | ------------------------ |
| 按值传递             | `void func(std::vector<T> vec)`           | 差       | 否                 | 需要独立副本             |
| 按引用传递           | `void func(std::vector<T>& vec)`          | 优       | 是                 | 需要修改原数据           |
| 按常量引用传递       | `void func(const std::vector<T>& vec)`    | 优       | 否                 | 只读操作                 |
| 传递指针             | `void func(std::vector<T>* vec)`          | 优       | 是                 | 动态内存或可选参数       |
| 传递迭代器范围       | `void func(Iterator begin, Iterator end)` | 优       | 取决于实现         | 泛型处理任意容器或子范围 |
| 移动语义（右值引用） | `void func(std::vector<T>&& vec)`         | 优       | 是（转移所有权）   | 高效转移数据             |

### **最佳实践**

1. **优先使用常量引用**（`const std::vector<T>&`）传递只读参数。
2. **需要修改时用引用**（`std::vector<T>&`）。
3. **避免按值传递大** `vector`（除非明确需要副本）。
4. **移动语义优化性能**：当传递临时对象或显式转移所有权时使用。





# [**lvalue,rvalue**](https://zhuanlan.zhihu.com/p/138210501)**（左值和右值）**

**左值(lvalue, left value)**，顾名思义就是赋值符号左边的值。准确来说， 左值是表达式（不一定是赋值表达式）后依然存在的持久对象。

**右值(rvalue, right value)**，右边的值，是指表达式结束后就不再存在的临时对象。

```c++
int a;  
a = 2;  //a是左值，2是右值
a = 3;  //左值可以被更改，编译通过
2 = 3;  //右值不能被更改，错误

int b = 3;  
int* pb = &b;  //pb是左值，&b是右值，因为它是由取址运算符返回的值
&b = 0;  //错误，右值不能被更改

// lvalues:
int i = 42;
i = 43; // ok, i is an lvalue 
int* p = &i; // ok, i is an lvalue 
int& foo();
foo() = 42; // ok, foo() is an lvalue
int* p1 = &foo(); // ok, foo() is an lvalue
// rvalues: 
int foobar(); 
int j = 0;
j = foobar(); // ok, foobar() is an rvalue
int k = j + 2; // ok, j+2 is an rvalue
int* p2 = &foobar(); // error, cannot take the address of an rvalue 
j = 42; // ok, 42 is an rvalue
```

而 C++11 中为了引入强大的右值引用

，将右值的概念进行了进一步的划分，分为：纯右值、将亡值。

**纯右值(prvalue, pure rvalue)**，纯粹的右值，没有标识符、不可以取地址的表达式， 要么是纯粹的字面量，例如 10, true； 要么是求值结果相当于字面量或匿名临时对象，例如 1+2。非引用返回的临时变量、运算表达式产生的临时变量、 原始字面量、Lambda 表达式都属于纯右值。









# **声明和定义**

C++ 语言支持"分别编译"（separatecompilation）。也就是说，一个程序所有的内容，可以分成不同的部分分别放在不同的  .cpp 文件里。.cpp  文件里的东西都是相对独立的，在编译（compile）时不需要与其他文件互通，只需要在编译成目标文件后再与其他的目标文件做一次链接（link）就行了。比如，在文件 a.cpp 中`定义`了一个全局函数 "void a(){}"，而在文件 b.cpp 中需要调用这个函数。即使这样，文件 a.cpp 和文件  b.cpp 并不需要相互知道对方的存在，而是可以分别地对它们进行编译，编译成目标文件之后再链接，整个程序就可以运行了。

这是怎么实现的呢？从写程序的角度来讲，很简单。在文件 b.cpp 中，在调用 "void a()" 函数之前，先`声明`一下这个函数  "voida();"，就可以了。这是因为编译器在编译 b.cpp 的时候会生成一个符号表（symbol table），像 "void a()"  这样的看不到定义的符号，就会被存放在这个表中。再进行链接的时候，编译器就会在别的目标文件中去寻找这个符号的定义。一旦找到了，程序也就可以顺利地生成了。



注意这里提到了两个概念，一个是"定义"，一个是"声明"。简单地说，"定义"就是把一个符号完完整整地描述出来：它是变量还是函数，返回什么类型，需要什么参数等等。而"声明"则只是声明这个符号的存在，即告诉编译器，这个符号是在其他文件中定义的，我这里先用着，你链接的时候再到别的地方去找找看它到底是什么吧。定义的时候要按 C++  语法完整地定义一个符号（变量或者函数），而声明的时候就只需要写出这个符号的原型了。需要注意的是，一个符号，在整个程序中可以被声明多次，但却要且仅要被定义一次。



# [**头文件**](https://www.runoob.com/w3cnote/cpp-header.html)

`#include` 的作用是把它后面所写的那个文件的内容，完完整整地、一字不改地包含到当前的文件中来。值得一提的是，它本身是没有其它任何作用与副功能的，它的作用就是把每一个它出现的地方，替换成它后面所写的那个文件的内容。简单的文本替换，别无其他。

## **引入方式**

`#include <stdout>`直接搜索系统中的文件

`#include "stdout"`优先搜索当前目录（指定目录）下的文件

## 头文件中应该写什么

头文件的作用就是被其他的 .cpp 包含进去的。它们本身并不参与编译，但实际上，它们的内容却在多个 .cpp  文件中得到了编译。通过"定义只能有一次"的规则，我们很容易可以得出，头文件中应该只放变量和函数的声明，而不能放它们的定义。因为一个头文件的内容实际上是会被引入到多个不同的 .cpp文件中的，并且它们都会被编译。放声明当然没事，如果放了定义，那么也就相当于在多个文件中出现了对于一个符号（变量或函数）的定义，纵然这些定义都是相同的，但对于编译器来说，这样做不合法。

所以，应该记住的一点就是，.h头文件中，只能存在变量或者函数的声明，而不要放定义。即，只能在头文件中写形如：extern int a; 和 void f(); 的句子。这些才是声明。如果写上 inta;或者 void f() {} 这样的句子，那么一旦这个头文件被两个或两个以上的 .cpp 文件包含的话，编译器会立马报错。

## **例外**

### **1.**

头文件中可以写 const 对象的定义。因为全局的 const 对象默认是没有 extern 的声明的，所以它只在当前文件中有效。把这样的对象写进头文件中，即使它被包含到其他多个 .cpp 文件中，这个对象也都只在包含它的那个文件中有效，对其他文件来说是不可见的，所以便不会导致多重定义。同时，因为这些 .cpp 文件中的该对象都是从一个头文件中包含进去的，这样也就保证了这些 .cpp 文件中的这个 const 对象的值是相同的，可谓一举两得。同理，static 对象的定义也可以放进头文件。

### **2.**

头文件中可以写内联函数（inline）的定义。因为inline函数是需要编译器在遇到它的地方根据它的定义把它内联展开的，而并非是普通函数那样可以先声明再链接的（内联函数不会链接），所以编译器就需要在编译时看到内联函数的完整定义才行。如果内联函数像普通函数一样只能定义一次的话，这事儿就难办了。因为在一个文件中还好，我可以把内联函数的定义写在最开始，这样可以保证后面使用的时候都可以见到定义；但是，如果我在其他的文件中还使用到了这个函数那怎么办呢？这几乎没什么太好的解决办法，因此 C++ 规定，内联函数可以在程序中定义多次，只要内联函数在一个 .cpp 文件中只出现一次，并且在所有的 .cpp 文件中，这个内联函数的定义是一样的，就能通过编译。那么显然，把内联函数的定义放进一个头文件中是非常明智的做法。

### **3.**

头文件中可以写类（class）的定义。因为在程序中创建一个类的对象时，编译器只有在这个类的定义完全可见的情况下，才能知道这个类的对象应该如何布局，所以，关于类的定义的要求，跟内联函数是基本一样的。所以把类的定义放进头文件，在使用到这个类的 .cpp 文件中去包含这个头文件，是一个很好的做法。在这里，值得一提的是，类的定义中包含着数据成员和函数成员。数据成员是要等到具体的对象被创建时才会被定义（分配空间），但函数成员却是需要在一开始就被定义的，这也就是我们通常所说的类的实现。一般，我们的做法是，把类的定义放在头文件中，而把函数成员的实现代码放在一个 .cpp 文件中。这是可以的，也是很好的办法。不过，还有另一种办法。那就是直接把函数成员的实现代码也写进类定义里面。在 C++ 的类中，如果函数成员在类的定义体中被定义，那么编译器会视这个函数为内联的。因此，把函数成员的定义写进类定义体，一起放进头文件中，是合法的。注意一下，如果把函数成员的定义写在类定义的头文件中，而没有写进类定义中，这是不合法的，因为这个函数成员此时就不是内联的了。一旦头文件被两个或两个以上的 .cpp 文件包含，这个函数成员就被重定义了。

### **4**

.h 文件中能包含： static 普通变量和普通函数的定义，但是不能包含，static 成员函数和成员变量的定义。

原因在于 static 这个关键词其实有两个不同的含义：

- static 修饰普通的变量和函数时。
- static 关键字是为了限制可见性。



# [**指针**](https://www.runoob.com/cplusplus/cpp-pointers.html)





# **corontine(协程)（库）**

[协程是什么？怎么来的？它有什么作用？](https://blog.csdn.net/weixin_48475611/article/details/114001159)

[如何编写 C++ 20 协程(Coroutines)](https://zhuanlan.zhihu.com/p/355100152)

[The Coroutine in C++ 20 协程初探](https://zhuanlan.zhihu.com/p/237952115)







# [**struct**](https://www.runoob.com/cplusplus/cpp-struct.html)

# **->**

https://blog.csdn.net/ultramand/article/details/135006841

https://www.zhihu.com/tardis/zm/art/165992745?source_id=1005





# [**static**](https://www.runoob.com/w3cnote/cpp-static-usage.html)**（关键字）**

static 是 C/C++ 中很常用的修饰符，它被用来控制变量的存储方式和可见性。

## **总的来说**

- （1）在修饰变量的时候，static 修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。
- （2）static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 extern 外部声明也不可以。
- （3）static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0。
- （4）不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰。
- （5）考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）。

**静态全局变量有以下特点：**

- （1）静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量;
- （2）未经初始化的静态全局变量会被程序自动初始化为0（在函数体内声明的自动变量的值是随机的，除非它被显式初始化，而在函数体外被声明的自动变量也会被初始化为 0）；
- （3）静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的。

**优点：**静态全局变量不能被其它文件所用；其它文件中可以定义相同名字的变量，不会发生冲突。

**（1）全局变量和全局静态变量的区别**

- 1）全局变量是不显式用 static 修饰的全局变量，全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过 extern 全局变量名的声明，就可以使用全局变量。
- 2）全局静态变量是显式用 static 修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用 extern 声明也不能使用。

## **用法**

### 在 C++ 中

static 关键字最基本的用法是：

- 1、被 static 修饰的变量属于类变量，可以通过类名.变量名直接引用，而不需要 new 出一个类来
- 2、被 static 修饰的方法属于类方法，可以通过类名.方法名直接引用，而不需要 new 出一个类来

被 static 修饰的变量、被 static 修饰的方法统一属于类的静态资源，是类实例之间共享的，换言之，一处变、处处变。

在 C++ 中，静态成员是属于整个类的而不是某个对象，静态成员变量只存储一份供所有对象共用。所以在所有对象中都可以共享它。使用静态成员变量实现多个对象之间的数据共享不会破坏隐藏的原则，保证了安全性还可以节省内存。

静态成员的定义或声明要加个关键 static。静态成员可以通过双冒号来使用即 <类名>::<静态成员名>。

```c++
class Point  
{  
public:   
    void init()  //not use static
    {    
    }  
    static void output()  //use static
    {  
    }  
};  
void main()  
{  
    Point::init();  //Error
    Point::output();  //OK
}

// _________________________________________________________________


class Point  
{  
public:   
    void init()  
    {    
    }  
    static void output()  
    {  
    }  
}; 
void main()  
{  
    Point pt;  
    pt.init();  //ok
    pt.output();  //ok
}

// ___________________________________________________________________
// 此外
// 静态成员函数中不能引用非静态成员
// 类的非静态成员函数可以调用用静态成员函数，但反之不能。
// 类的静态成员变量必须先初始化再使用
```

- 1）静态方法能不能引用非静态资源？不能，实例化对象的时候才会产生的东西，对于初始化后就存在的静态资源来说，根本不认识它。
- 2）静态方法里面能不能引用静态资源？可以，因为都是类初始化的时候加载的，大家相互都认识。
- 3）非静态方法里面能不能引用静态资源？可以，非静态方法就是实例方法，那是实例化对象之后才产生的，那么属于类的内容它都认识。



# [**filesystem**](https://blog.csdn.net/qq_40946921/article/details/91394589)**（库）**

const 是 constant 的缩写，本意是不变的，不易改变的意思。在 C++ 中是用来修饰内置类型变量，自定义对象，成员函数，返回值，函数参数。

C++ const 允许指定一个语义约束，编译器会强制实施这个约束，允许程序员告诉编译器某值是保持不变的。如果在编程中确实有某个值保持不变，就应该明确使用const，这样可以获得编译器的帮助。



# [**const**](https://www.runoob.com/w3cnote/cpp-const-keyword.html)**（关键字）**

const 是 constant 的缩写，本意是不变的，不易改变的意思。在 C++ 中是用来修饰内置类型变量，自定义对象，成员函数，返回值，函数参数。

C++ const 允许指定一个语义约束，编译器会强制实施这个约束，允许程序员告诉编译器某值是保持不变的。如果在编程中确实有某个值保持不变，就应该明确使用const，这样可以获得编译器的帮助。

## **一、const修饰普通类型的变量**

```c++
#include<iostream>
 
using namespace std;
 
int main(void)
{
    const int  a = 7;
    int  *p = (int*)&a;
    *p = 8;
    cout<<a;
    return 0;
}
//输出为7
//不会报错，查看地址的话也是8，但是编译器认为a的值就是7,而不是从它的内存地址重新获取值
//所以千万不要写这样的风险代码
```

## **二、const 修饰指针变量**

const 修饰指针变量有以下三种情况。

- A: const 修饰指针指向的内容，则内容为不可变量。
- B: const 修饰指针，则指针为不可变量。
- C: const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。

对于 A: 

```c++
const int *p = 8;

*p = 9;//Error:指针指向的内容 8 不可改变。简称左定值，因为 const 位于 * 号的左边。
```

对于B：

```c++
int a = 8
int b = 9
int * const p = &a
p = &b//Error:指针指向的地址不可变
```

对于C：

则是AB的合并，

记"左定值，右定向，const修饰不变量"。

## **三、const参数传递和函数返回值。**

A：值传递的 const 修饰传递，一般这种情况不需要 const 修饰，因为函数会自动产生临时变量复制实参值。

```c++
#include<iostream>
 
using namespace std;
 
void Cpf(const int a)
{
    cout<<a;
    // ++a;  是错误的，a 不能被改变
}
 
int main(void)
 
{
    Cpf(8);
    return 0;
}
```

B：当 const 参数为指针时，可以防止指针被意外篡改。

```c++
#include<iostream>
 
using namespace std;
 
void Cpf(int *const a)
{
    cout<<*a<<" ";//输出8
    *a = 9;
}
 
int main(void)
{
    int a = 8;
    Cpf(&a);
    cout<<a; // a 为 9
  return 0;
}
```

C：自定义类型的参数传递，需要临时对象复制参数，对于临时对象的构造，需要调用构造函数，比较浪费时间，因此我们采取 const 外加引用传递的方法。

并且对于一般的 int、double 等内置类型，我们不采用引用的传递方式

```c++
#include<iostream>
 
using namespace std;
 
class Test
{
public:
    Test(){}
    Test(int _m):_cm(_m){}
    int get_cm()const
    {
       return _cm;
    }
 
private:
    int _cm;
};
 
 
 
void Cmf(const Test& _tt)//引用传递可以避免构造副本对象，const可以避免被修改
{
    cout<<_tt.get_cm();
}
 
int main(void)
{
    Test t(8);
    Cmf(t);
    system("pause");
    return 0;
}
```

## **四、const修饰返回类型**

### **1.修饰内置类型**

```c++
const int func(){}
//有无const都一样，接收这个返回值的声明符依旧可以修改
```

### **2.修饰自定义类型**

const 修饰自定义类型的作为返回值，此时返回的值不能作为左值使用，既不能被赋值，也不能被修改。

### **3.**

const 修饰返回的指针或者引用，是否返回一个指向 const 的指针，取决于我们想让用户干什么。



## **五、**const修饰类成员函数

const 修饰类成员函数，其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为 const 成员函数。

**注意：**const 关键字不能与 static 关键字同时使用，因为 static 关键字修饰静态成员函数，静态成员函数不含有 this 指针，即不能实例化，const 成员函数必须具体到某一实例。

下面的 get_cm()const; 函数用到了 const 成员函数：

```c++
#include<iostream>using namespace std;
 
class Test{public:
    Test(){}Test(int _m):_cm(_m){}int get_cm()const{return _cm;
    }private:
    int _cm;
};
 
 
 
void Cmf(const Test& _tt){cout<<_tt.get_cm();
}int main(void){Test t(8);
    Cmf(t);
    return 0;
}
```

如果 get_cm() 去掉 const 修饰，则 Cmf 传递的 const _tt 即使没有改变对象的值，编译器也认为函数会改变对象的值，所以我们尽量按照要求将所有的不需要改变对象内容的函数都作为 const 成员函数。

如果有个成员函数想修改对象中的某一个成员怎么办？这时我们可以使用 mutable 关键字修饰这个成员，mutable 的意思也是易变的，容易改变的意思，被 mutable 关键字修饰的成员可以处于不断变化中，如下面的例子。

```c++
#include<iostream>using namespace std;
class Test{public:
    Test(int _m,int _t):_cm(_m),_ct(_t){}void Kf()const{
        ++_cm; // 错误
        ++_ct; // 正确}private:
    int _cm;
    mutable int _ct;
};
 
int main(void){Test t(8,7);
    return 0;
}
```

这里我们在 Kf()const 中通过 ++_ct; 修改 _ct 的值，但是通过 ++_cm 修改 _cm 则会报错。因为 ++_cm 没有用 mutable 修饰。

# [**volatile**](https://www.runoob.com/w3cnote/c-volatile-keyword.html)**(关键字)**



# **enum枚举**

**枚举类型的定义：**枚举类型(enumeration)是 C++ 中的一种派生数据类型，它是由用户定义的若干枚举常量的集合

## **定义和常量**

格式：`enum <typename> {<list>}`

enum指明其后的标识符是一个枚举类型的名字

list是由枚举常量构成。"枚举常量"或称"枚举成员"，是以标识符形式表示的整型量，表示枚举类型的取值。枚举常量表列出枚举类型的所有取值，各枚举常量之间以"，"间隔，且必须各不相同。取值类型与条件表达式相同。

```c++
enum color_set1 {RED, BLUE, WHITE, BLACK}; // 定义枚举类型color_set1
enum week {Sun, Mon, Tue, Wed, Thu, Fri, Sat}; // 定义枚举类型week
```

枚举常量代表该枚举类型的变量可能取的值，编译系统为每个枚举常量指定一个整数值，默认状态下，这个整数就是所列举元素的序号，序号从0开始。 可以在定义枚举类型时为部分或全部枚举常量指定整数值，在指定值之前的枚举常量仍按默认方式取值，而指定值之后的枚举常量按依次加1的原则取值。 各枚举常量的值可以重复。例如：

```c++
枚举常量只能以标识符形式表示，而不能是整型、字符型等文字常量。例如，以下定义非法：enum fruit_set {apple, orange, banana=1, peach, grape}
//枚举常量apple=0,orange=1, banana=1,peach=2,grape=3。

enum week {Sun=7, Mon=1, Tue, Wed, Thu, Fri, Sat};
//枚举常量Sun,Mon,Tue,Wed,Thu,Fri,Sat的值分别为7、1、2、3、4、5、6。


//枚举常量只能以标识符形式表示，而不能是整型、字符型等文字常量。例如，以下定义非法：
enum letter_set {'a','d','F','s','T'}; //error:枚举常量不能是字符常量
enum year_set{2000,2001,2002,2003,2004,2005}; //error:枚举常量不能是整型常量

enum letter_set {a, d, F, s, T};//ok
enum year_set{y2000, y2001, y2002, y2003, y2004, y2005};//ok
```

## **变量**

在定义了枚举类型后，就可以定义该类型的变量

```c++
classname variantname;
```



`enum class classname` 和`enum classname` 是不一样的









# **资源与对象**

## **资源的生命周期**

资源的生命周期是指程序使用的某种资源（比如内存、文件、网络连接等）从获取到释放的整个过程。资源通常是通过对象来管理的，但资源的生命周期和对象的生命周期不一定完全一致。

- 获取资源：比如通过 `new` 分配内存，或者通过 `fopen` 打开文件。
- 使用资源：比如读写文件，或者使用动态分配的内存。
- 释放资源：比如通过 `delete` 释放内存，或者通过 `fclose` 关闭文件。

```c++
void example() {
    int* ptr = new int(10);  // 获取资源：动态分配内存
    std::cout << *ptr << std::endl;  // 使用资源
    delete ptr;  // 释放资源
}
```

在这个例子中，`ptr` 指向的内存资源的生命周期从 `new` 开始，到 `delete` 结束。

## **对象的生命周期**

对象的生命周期是指一个对象从创建到销毁的整个过程。在C++中，对象的生命周期可以分为以下几个阶段：

- 创建：当你定义一个对象时（比如 `int a;` 或者 `MyClass obj;`），对象就被创建了。
- 使用：在对象创建后，你可以使用它（比如调用它的方法或访问它的数据）。
- 销毁：当对象不再需要时，它会被销毁（比如局部变量在函数结束时自动销毁，或者手动释放动态分配的对象）。

```c++
void example() {
    int a = 10;  // 对象a被创建
    std::cout << a << std::endl;  // 使用a
}  // 函数结束，a被自动销毁
```

## **两者的关系**

对象可以用来管理资源，但需要确保资源的生命周期被正确处理，避免资源泄漏或无效访问。

- 对象是资源的“管理者”：对象可以用来管理资源。比如，C++中的智能指针（如 `std::unique_ptr`）就是一个对象，它负责管理动态分配的内存资源。
- 资源生命周期可能比对象长：如果资源没有正确释放，即使对象已经销毁，资源仍然会存在（比如内存泄漏）。
- 资源生命周期可能比对象短：如果资源被提前释放，对象可能会访问无效的资源（比如悬空指针）。



# **操作符**

## **::**

作用域解析操作符（Scope Resolution Operator）

它的主要作用是帮助我们在代码中明确地指定某个标识符（比如变量、函数、类等）属于哪个作用域。





# **输入和输出**

## `std::cout`

`std::cout` 是 C++ 标准库中的输出工具，属于 `<iostream>` 头文件。它的用法非常简单，直接用 `<<` 操作符输出内容即可。

```c++
#include <iostream>

int main() {
    int x = 10;
    double y = 3.14;
    std::string name = "Alice";

    std::cout << "x = " << x << ", y = " << y << ", name = " << name << std::endl;
}
```

- `<<` 操作符：用于将数据插入到输出流中。
- 链式调用：可以连续使用 `<<` 输出多个数据。
- `std::endl`：用于换行并刷新输出缓冲区。

## `std::cin`

`std::cin` 用于从控制台读取用户输入。

```c++
#include <iostream>

int main() {
    int age;
    std::string name;

    std::cout << "Enter your name: ";
    std::cin >> name;

    std::cout << "Enter your age: ";
    std::cin >> age;

    std::cout << "Hello, " << name << "! You are " << age << " years old." << std::endl;
}
```

- `>>` 操作符：用于从输入流中提取数据。
- 自动类型匹配：`std::cin` 会根据变量的类型自动解析输入。
- 空格分隔：默认情况下，`std::cin` 以空格或换行符分隔输入。






``

# **遍历**

## **for**

```c++
for (auto i : arrayname){}

// 或者
for (auto i = ito.begin(); i!=ito.end(); i++){}
```
